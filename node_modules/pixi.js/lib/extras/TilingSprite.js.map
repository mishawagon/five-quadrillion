{"version":3,"sources":["../../src/extras/TilingSprite.js"],"names":["core","tempPoint","Point","TilingSprite","texture","width","height","tileTransform","TransformStatic","_width","_height","_canvasPattern","uvTransform","transform","pluginName","uvRespectAnchor","_onTextureUpdate","_texture","_renderWebGL","renderer","valid","updateLocalTransform","update","setObjectRenderer","plugins","render","_renderCanvas","baseTexture","hasLoaded","context","worldTransform","resolution","baseTextureResolution","modX","tilePosition","x","tileScale","_frame","modY","y","tempCanvas","CanvasRenderTarget","tint","cachedTint","tintedTexture","getTintedTexture","drawImage","source","createPattern","canvas","globalAlpha","worldAlpha","setTransform","a","b","c","d","tx","ty","scale","translate","anchor","setBlendMode","blendMode","fillStyle","fillRect","_calculateBounds","minX","_anchor","_x","minY","_y","maxX","maxY","_bounds","addFrame","getLocalBounds","rect","children","length","_localBoundsRect","Rectangle","getRectangle","call","containsPoint","point","applyInverse","x1","y1","destroy","from","Texture","fromFrame","frameId","utils","TextureCache","Error","fromImage","imageId","crossorigin","scaleMode","clampMargin","value","copy","position","Sprite"],"mappings":"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","file":"TilingSprite.js","sourcesContent":["import * as core from '../core';\nimport CanvasTinter from '../core/sprites/canvas/CanvasTinter';\nimport { default as TextureTransform } from './TextureTransform';\n\nconst tempPoint = new core.Point();\n\n/**\n * A tiling sprite is a fast way of rendering a tiling image\n *\n * @class\n * @extends PIXI.Sprite\n * @memberof PIXI.extras\n */\nexport default class TilingSprite extends core.Sprite\n{\n    /**\n     * @param {PIXI.Texture} texture - the texture of the tiling sprite\n     * @param {number} [width=100] - the width of the tiling sprite\n     * @param {number} [height=100] - the height of the tiling sprite\n     */\n    constructor(texture, width = 100, height = 100)\n    {\n        super(texture);\n\n        /**\n         * Tile transform\n         *\n         * @member {PIXI.TransformStatic}\n         */\n        this.tileTransform = new core.TransformStatic();\n\n        // /// private\n\n        /**\n         * The with of the tiling sprite\n         *\n         * @member {number}\n         * @private\n         */\n        this._width = width;\n\n        /**\n         * The height of the tiling sprite\n         *\n         * @member {number}\n         * @private\n         */\n        this._height = height;\n\n        /**\n         * Canvas pattern\n         *\n         * @type {CanvasPattern}\n         * @private\n         */\n        this._canvasPattern = null;\n\n        /**\n         * transform that is applied to UV to get the texture coords\n         *\n         * @member {PIXI.extras.TextureTransform}\n         */\n        this.uvTransform = texture.transform || new TextureTransform(texture);\n\n        /**\n         * Plugin that is responsible for rendering this element.\n         * Allows to customize the rendering process without overriding '_renderWebGL' method.\n         *\n         * @member {string}\n         * @default 'tilingSprite'\n         */\n        this.pluginName = 'tilingSprite';\n\n        /**\n         * Whether or not anchor affects uvs\n         *\n         * @member {boolean}\n         * @default false\n         */\n        this.uvRespectAnchor = false;\n    }\n    /**\n     * Changes frame clamping in corresponding textureTransform, shortcut\n     * Change to -0.5 to add a pixel to the edge, recommended for transparent trimmed textures in atlas\n     *\n     * @default 0.5\n     * @member {number}\n     */\n    get clampMargin()\n    {\n        return this.uvTransform.clampMargin;\n    }\n\n    set clampMargin(value) // eslint-disable-line require-jsdoc\n    {\n        this.uvTransform.clampMargin = value;\n        this.uvTransform.update(true);\n    }\n\n    /**\n     * The scaling of the image that is being tiled\n     *\n     * @member {PIXI.ObservablePoint}\n     */\n    get tileScale()\n    {\n        return this.tileTransform.scale;\n    }\n\n    set tileScale(value) // eslint-disable-line require-jsdoc\n    {\n        this.tileTransform.scale.copy(value);\n    }\n\n    /**\n     * The offset of the image that is being tiled\n     *\n     * @member {PIXI.ObservablePoint}\n     */\n    get tilePosition()\n    {\n        return this.tileTransform.position;\n    }\n\n    set tilePosition(value) // eslint-disable-line require-jsdoc\n    {\n        this.tileTransform.position.copy(value);\n    }\n\n    /**\n     * @private\n     */\n    _onTextureUpdate()\n    {\n        if (this.uvTransform)\n        {\n            this.uvTransform.texture = this._texture;\n        }\n    }\n\n    /**\n     * Renders the object using the WebGL renderer\n     *\n     * @private\n     * @param {PIXI.WebGLRenderer} renderer - The renderer\n     */\n    _renderWebGL(renderer)\n    {\n        // tweak our texture temporarily..\n        const texture = this._texture;\n\n        if (!texture || !texture.valid)\n        {\n            return;\n        }\n\n        this.tileTransform.updateLocalTransform();\n        this.uvTransform.update();\n\n        renderer.setObjectRenderer(renderer.plugins[this.pluginName]);\n        renderer.plugins[this.pluginName].render(this);\n    }\n\n    /**\n     * Renders the object using the Canvas renderer\n     *\n     * @private\n     * @param {PIXI.CanvasRenderer} renderer - a reference to the canvas renderer\n     */\n    _renderCanvas(renderer)\n    {\n        const texture = this._texture;\n\n        if (!texture.baseTexture.hasLoaded)\n        {\n            return;\n        }\n\n        const context = renderer.context;\n        const transform = this.worldTransform;\n        const resolution = renderer.resolution;\n        const baseTexture = texture.baseTexture;\n        const baseTextureResolution = texture.baseTexture.resolution;\n        const modX = (this.tilePosition.x / this.tileScale.x) % texture._frame.width;\n        const modY = (this.tilePosition.y / this.tileScale.y) % texture._frame.height;\n\n        // create a nice shiny pattern!\n        // TODO this needs to be refreshed if texture changes..\n        if (!this._canvasPattern)\n        {\n            // cut an object from a spritesheet..\n            const tempCanvas = new core.CanvasRenderTarget(texture._frame.width,\n                                                        texture._frame.height,\n                                                        baseTextureResolution);\n\n            // Tint the tiling sprite\n            if (this.tint !== 0xFFFFFF)\n            {\n                if (this.cachedTint !== this.tint)\n                {\n                    this.cachedTint = this.tint;\n\n                    this.tintedTexture = CanvasTinter.getTintedTexture(this, this.tint);\n                }\n                tempCanvas.context.drawImage(this.tintedTexture, 0, 0);\n            }\n            else\n            {\n                tempCanvas.context.drawImage(baseTexture.source, -texture._frame.x, -texture._frame.y);\n            }\n            this._canvasPattern = tempCanvas.context.createPattern(tempCanvas.canvas, 'repeat');\n        }\n\n        // set context state..\n        context.globalAlpha = this.worldAlpha;\n        context.setTransform(transform.a * resolution,\n                           transform.b * resolution,\n                           transform.c * resolution,\n                           transform.d * resolution,\n                           transform.tx * resolution,\n                           transform.ty * resolution);\n\n        // TODO - this should be rolled into the setTransform above..\n        context.scale(this.tileScale.x / baseTextureResolution, this.tileScale.y / baseTextureResolution);\n\n        context.translate(modX + (this.anchor.x * -this._width),\n                          modY + (this.anchor.y * -this._height));\n\n        renderer.setBlendMode(this.blendMode);\n\n        // fill the pattern!\n        context.fillStyle = this._canvasPattern;\n        context.fillRect(-modX,\n                         -modY,\n                         this._width / this.tileScale.x * baseTextureResolution,\n                         this._height / this.tileScale.y * baseTextureResolution);\n    }\n\n    /**\n     * Updates the bounds of the tiling sprite.\n     *\n     * @private\n     */\n    _calculateBounds()\n    {\n        const minX = this._width * -this._anchor._x;\n        const minY = this._height * -this._anchor._y;\n        const maxX = this._width * (1 - this._anchor._x);\n        const maxY = this._height * (1 - this._anchor._y);\n\n        this._bounds.addFrame(this.transform, minX, minY, maxX, maxY);\n    }\n\n    /**\n     * Gets the local bounds of the sprite object.\n     *\n     * @param {PIXI.Rectangle} rect - The output rectangle.\n     * @return {PIXI.Rectangle} The bounds.\n     */\n    getLocalBounds(rect)\n    {\n        // we can do a fast local bounds if the sprite has no children!\n        if (this.children.length === 0)\n        {\n            this._bounds.minX = this._width * -this._anchor._x;\n            this._bounds.minY = this._height * -this._anchor._y;\n            this._bounds.maxX = this._width * (1 - this._anchor._x);\n            this._bounds.maxY = this._height * (1 - this._anchor._x);\n\n            if (!rect)\n            {\n                if (!this._localBoundsRect)\n                {\n                    this._localBoundsRect = new core.Rectangle();\n                }\n\n                rect = this._localBoundsRect;\n            }\n\n            return this._bounds.getRectangle(rect);\n        }\n\n        return super.getLocalBounds.call(this, rect);\n    }\n\n    /**\n     * Checks if a point is inside this tiling sprite.\n     *\n     * @param {PIXI.Point} point - the point to check\n     * @return {boolean} Whether or not the sprite contains the point.\n     */\n    containsPoint(point)\n    {\n        this.worldTransform.applyInverse(point, tempPoint);\n\n        const width = this._width;\n        const height = this._height;\n        const x1 = -width * this.anchor._x;\n\n        if (tempPoint.x > x1 && tempPoint.x < x1 + width)\n        {\n            const y1 = -height * this.anchor._y;\n\n            if (tempPoint.y > y1 && tempPoint.y < y1 + height)\n            {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Destroys this tiling sprite\n     *\n     */\n    destroy()\n    {\n        super.destroy();\n\n        this.tileTransform = null;\n        this.uvTransform = null;\n    }\n\n    /**\n     * Helper function that creates a new tiling sprite based on the source you provide.\n     * The source can be - frame id, image url, video url, canvas element, video element, base texture\n     *\n     * @static\n     * @param {number|string|PIXI.BaseTexture|HTMLCanvasElement|HTMLVideoElement} source - Source to create texture from\n     * @param {number} width - the width of the tiling sprite\n     * @param {number} height - the height of the tiling sprite\n     * @return {PIXI.Texture} The newly created texture\n     */\n    static from(source, width, height)\n    {\n        return new TilingSprite(core.Texture.from(source), width, height);\n    }\n\n    /**\n     * Helper function that creates a tiling sprite that will use a texture from the TextureCache based on the frameId\n     * The frame ids are created when a Texture packer file has been loaded\n     *\n     * @static\n     * @param {string} frameId - The frame Id of the texture in the cache\n     * @param {number} width - the width of the tiling sprite\n     * @param {number} height - the height of the tiling sprite\n     * @return {PIXI.extras.TilingSprite} A new TilingSprite using a texture from the texture cache matching the frameId\n     */\n    static fromFrame(frameId, width, height)\n    {\n        const texture = core.utils.TextureCache[frameId];\n\n        if (!texture)\n        {\n            throw new Error(`The frameId \"${frameId}\" does not exist in the texture cache ${this}`);\n        }\n\n        return new TilingSprite(texture, width, height);\n    }\n\n    /**\n     * Helper function that creates a sprite that will contain a texture based on an image url\n     * If the image is not in the texture cache it will be loaded\n     *\n     * @static\n     * @param {string} imageId - The image url of the texture\n     * @param {number} width - the width of the tiling sprite\n     * @param {number} height - the height of the tiling sprite\n     * @param {boolean} [crossorigin] - if you want to specify the cross-origin parameter\n     * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - if you want to specify the scale mode,\n     *  see {@link PIXI.SCALE_MODES} for possible values\n     * @return {PIXI.extras.TilingSprite} A new TilingSprite using a texture from the texture cache matching the image id\n     */\n    static fromImage(imageId, width, height, crossorigin, scaleMode)\n    {\n        return new TilingSprite(core.Texture.fromImage(imageId, crossorigin, scaleMode), width, height);\n    }\n\n    /**\n     * The width of the sprite, setting this will actually modify the scale to achieve the value set\n     *\n     * @member {number}\n     */\n    get width()\n    {\n        return this._width;\n    }\n\n    set width(value) // eslint-disable-line require-jsdoc\n    {\n        this._width = value;\n    }\n\n    /**\n     * The height of the TilingSprite, setting this will actually modify the scale to achieve the value set\n     *\n     * @member {number}\n     */\n    get height()\n    {\n        return this._height;\n    }\n\n    set height(value) // eslint-disable-line require-jsdoc\n    {\n        this._height = value;\n    }\n}\n"]}